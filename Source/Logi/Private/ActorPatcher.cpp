#include "ActorPatcher.h"

#include "K2Node_CallFunction.h"
#include "K2Node_Event.h"
#include "K2Node_FunctionEntry.h"
#include "K2Node_Select.h"
#include "MaterialDomain.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "Utils/ActorUtils.h"
#include "Utils/BlueprintUtils.h"


namespace Logi::ActorPatcher
{
	// Creates Thermal Material on already existing material of the actor(?)
	void CreateThermalMaterial(bool& success, FString& statusMessage) {
		#if WITH_EDITOR
			success = false;

			//Load the thermal material function
			UMaterialFunctionInterface* thermalMaterialFunction = LoadObject<UMaterialFunctionInterface>(nullptr, TEXT("/Game/Logi_ThermalCamera/Materials/MF_Logi_ThermalMaterialFunction.MF_Logi_ThermalMaterialFunction"));

			//Check if the function was loaded successfully
			if (!thermalMaterialFunction) {
				statusMessage = TEXT("Failed to load MF_Logi_ThermalMaterialFunction in CreateThermalMaterial. Thermal material could not be created.");
				return;
			}

			// Define names, paths and packages
			const FString materialName = TEXT("M_Logi_ThermalMaterial");
			const FString packagePath = TEXT("/Game/Logi_ThermalCamera/Materials/");
			const FString materialPath = packagePath + materialName;
			UPackage* package = CreatePackage(*materialPath);

			if (!package)
			{
				statusMessage = TEXT("Failed to create Package in CreateThermalMaterial. Thermal material could not be created.");
				return;
			}

			//Create the material
			UMaterial* material = NewObject<UMaterial>(package, *materialName, RF_Public | RF_Standalone);

			if (!material)
			{
				statusMessage = TEXT("Failed to create material in CreateThermalMaterial. Thermal material could not be created.");
				return;
			}

			// Set material properties
			material->MaterialDomain = MD_Surface;
			material->BlendMode = BLEND_Opaque;
			material->SetShadingModel(MSM_DefaultLit);
			material->bUseMaterialAttributes = true;

			// Create a node for the MF_Logi_ThermalMaterialFunction
			UMaterialExpressionMaterialFunctionCall* functionCall = NewObject<UMaterialExpressionMaterialFunctionCall>(material);
			functionCall->Material = material;
			functionCall->SetMaterialFunction(thermalMaterialFunction);
			functionCall->UpdateFromFunctionResource();
			functionCall->MaterialExpressionEditorX = -400;
			functionCall->MaterialExpressionEditorY = 0;

			//Connecdt the MF_Logi_ThermalMaterialFunction to the materials output node
			material->GetEditorOnlyData()->MaterialAttributes.Expression = functionCall;

			// Add the expression to the material
			material->GetEditorOnlyData()->ExpressionCollection.Expressions.Add(functionCall);

			// Mark the material as edited
			material->PreEditChange(nullptr);
			material->PostEditChange();
			material->MarkPackageDirty();

			//Register the material in the asset registry
			FAssetRegistryModule::AssetCreated(material);

			// Save the material
			const FString filePath = FPackageName::LongPackageNameToFilename(materialPath, FPackageName::GetAssetPackageExtension());

			if (!UPackage::SavePackage(package, material, EObjectFlags::RF_Public | RF_Standalone, *filePath))
			{
				statusMessage = TEXT("Failed to save the material package in CreateThermalMaterial. Could not create thermal material.");
				return;
			}

			success = true;
			statusMessage = TEXT("Successfully created thermal material.");

		#else
			success = false;
			statusMessage = TEXT("The function CreateThermalMaterial can only be run in editor builds");
		#endif
	}

	// Finds all Actor blueprints in the project, that are not Logi-created
	void FindAllNonLogiActorBlueprintsInProject(TArray<FAssetData>& OutActorBlueprints) {
		//Get the asset registry module
		FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>("AssetRegistry");

		//Get the asset registry inside the asset registry module
		IAssetRegistry& Registry = AssetRegistryModule.Get();

		// verify registry is up to date
		Registry.SearchAllAssets(true);

		// Create filert for the search
		FARFilter Filter;
		Filter.ClassPaths.Add(UBlueprint::StaticClass()->GetClassPathName());
		Filter.PackagePaths.Add(FName("/Game"));
		Filter.bRecursivePaths = true;

		//create array to hold blueprints found
		TArray<FAssetData> AssetList;

		//Get all blueprints in the /games (content) folder and add them to the AssetsList list
		Registry.GetAssets(Filter, AssetList);

		//Filter out all blueprints that are not actors
		for (const FAssetData& Asset : AssetList) {

			// Skipping the Logi_ThermalCamera folder
			if (Asset.PackagePath.ToString().StartsWith("/Game/Logi_ThermalCamera")) {
				continue;
			}

			//Check if the blueprint has a parent class
			FString ParentClassPath;

			//Get the parent class path and set it to the ParentClassPath variable to that path
			if (Asset.GetTagValue<FString>("ParentClass", ParentClassPath))
			{
				// Remove the autogenerated "_C" suffix from the class path
				ParentClassPath.RemoveFromEnd(TEXT("_C"), ESearchCase::IgnoreCase);

				//Tries to find the actualparent class object from the classe's path
				UClass* ParentClass = FindObject<UClass>(nullptr, *ParentClassPath);

				//Check if the parent class is a child of the AActor, i.e if it's an Actor blueprint
				if (ParentClass && ParentClass->IsChildOf(AActor::StaticClass()))
				{
					//Actor blueprint added to the list
					OutActorBlueprints.Add(Asset);
				}
			}
		}
	}

	void AddLogiVariablesToActorBlueprint(const FAssetData& actor) {

		//Cast asset data to blueprint type
		UBlueprint* blueprint = Cast<UBlueprint>(actor.GetAsset());

		//Validate that the cast was successfull
		if(!blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Failed to load blueprint from asset data: %s"), *actor.AssetName.ToString());
			return;
		}

		//Create bolean type
		FEdGraphPinType boolType;
		boolType.PinCategory = UEdGraphSchema_K2::PC_Boolean;

		//Create float type
		FEdGraphPinType floatType;
		floatType.PinCategory = UEdGraphSchema_K2::PC_Real;
		floatType.PinSubCategory = UEdGraphSchema_K2::PC_Float;

		//Create index type
		FEdGraphPinType intType;
		intType.PinCategory = UEdGraphSchema_K2::PC_Int;

		//Create Linear Color type
		FEdGraphPinType linearColorType;
		linearColorType.PinCategory = UEdGraphSchema_K2::PC_Struct;
		linearColorType.PinSubCategoryObject = TBaseStructure<FLinearColor>::Get();

		//Create vector type
		FEdGraphPinType vectorType;
		vectorType.PinCategory = UEdGraphSchema_K2::PC_Struct;
		vectorType.PinSubCategoryObject = TBaseStructure<FVector>::Get();

		//Print status
		UE_LOG(LogTemp, Warning, TEXT("Adding variable to actor blueprint"));

		//Add variables to the blueprint
		Logi::BlueprintUtils::AddVariableToBlueprintClass(blueprint, "Logi_Hot", boolType, true, "false");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(blueprint, "Logi_BaseTemperature", floatType, true, "0.0");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(blueprint, "Logi_MaxTemperature", floatType, true, "25.0");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(blueprint, "Logi_CurrentTemperature", floatType, true, "25.0");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(blueprint, "Logi_MaterialIndex", intType, false, "0");
	}

	void AddNodeSetupToSetupFunction(UEdGraph* functionGraph, UK2Node_FunctionEntry* entryNode) {
		//Validate function graph

		if (!functionGraph) {
			UE_LOG(LogTemp, Error, TEXT("Function graph is a nullpointer, cannot add nodes to the graph."));
			return;
		}

		//validate entry node
		if (!entryNode) {
			UE_LOG(LogTemp, Error, TEXT("No function entry node is a nullpointer. Cannot add nodes to the graph."));
			return;
		}

		// Find the function blueprint
		UBlueprint* blueprint = Cast<UBlueprint>(functionGraph->GetOuter());

		//Validate the blueprint
		if (!blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Could not find the blueprint linked to the blueprint function"));
			return;
		}

		int xPosition = 300;

		//Check every variable in the blueprint for mesh components
		TArray<FName> meshComponentNames = ActorUtils::FindAllMeshComponentsInBlueprint(blueprint);

		//Check if the meshVariableName is empty if so, skipping implementation.
		if (meshComponentNames.Num() == 0) {
			UE_LOG(LogTemp, Warning, TEXT("No skeletal mesh component found in blueprint '%s', skipping implementation."), *blueprint->GetName());
			return;
		}

		//Get the function graphs schema
		const UEdGraphSchema_K2* Schema = CastChecked<UEdGraphSchema_K2>(functionGraph->GetSchema());

		//Create Logi_Hot variable getter node
		UK2Node_VariableGet* logiHotGetNode = BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_Hot"), xPosition, 200);

		//Update xPosition
		xPosition += 100;

		//Creating nodes inside the function graph
		UK2Node_IfThenElse* branchNode = BlueprintUtils::CreateBPBranchNode(functionGraph, xPosition, 0);

		//Update xPosition
		xPosition += 300;

		//Connect the entry node to the branch node
		UEdGraphPin* execPin = entryNode->FindPin(UEdGraphSchema_K2::PN_Then);

		//Connect the Logi_Hot variable getter node to the branch node
		Schema->TryCreateConnection(logiHotGetNode->FindPin(FName("Logi_Hot")), branchNode->GetConditionPin());

		//Connect the entry node to the branch node
		Schema->TryCreateConnection(execPin, branchNode->GetExecPin());

		// Pointers to track the last SetRenderCustomDepth node in the true/false chain
		UK2Node_CallFunction* previousTrueExecNode = nullptr;
		UK2Node_CallFunction* previousFalseExecNode = nullptr;

		//Create mesh getter nodes and set render custom deapth node for each mesh in the blueprint
		for (int32 i = 0; i < meshComponentNames.Num(); ++i) {

			//Get the mesh variable name
			FName meshVariableName = meshComponentNames[i];

			//Create mesh getter nodes
			UK2Node_VariableGet* meshGetterNodeTrue = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, meshVariableName, xPosition, -400);
			UK2Node_VariableGet* meshGetterNodeFalse = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, meshVariableName, xPosition, 500);

			//Create set render custom depth nodes
			UK2Node_CallFunction* setRenderDepthNodeTrue = Logi::BlueprintUtils::CreateBPSetRenderDepthNode(functionGraph, true, xPosition, -200);
			UK2Node_CallFunction* setRenderDepthNodeFalse = Logi::BlueprintUtils::CreateBPSetRenderDepthNode(functionGraph, false, xPosition, 200);

			//Try to find the target pin for the set render custom depth nodes
			UEdGraphPin* trueTargetPin = setRenderDepthNodeTrue->FindPin(UEdGraphSchema_K2::PN_Self);
			UEdGraphPin* falseTargetPin = setRenderDepthNodeFalse->FindPin(UEdGraphSchema_K2::PN_Self);

			//Connect mesh getter nodes to set render custom depth nodes
			if (trueTargetPin && meshGetterNodeTrue->GetValuePin()) {
				Schema->TryCreateConnection(meshGetterNodeTrue->GetValuePin(), trueTargetPin);
			}

			if (falseTargetPin && meshGetterNodeFalse->GetValuePin()) {
				Schema->TryCreateConnection(meshGetterNodeFalse->GetValuePin(), falseTargetPin);
			}

			//Check if this is the first set render custom depth node in the chains
			if (i == 0) {
				//Connect the branch node to the set render custom depth nodes
				Schema->TryCreateConnection(branchNode->GetThenPin(), setRenderDepthNodeTrue->GetExecPin());
				Schema->TryCreateConnection(branchNode->GetElsePin(), setRenderDepthNodeFalse->GetExecPin());

				//Set the previous set render custom depth nodes to the current set render custom depth nodes
			}
			else {
				//Connect the previous set render custom depth node to the current set render custom depth node
				Schema->TryCreateConnection(previousTrueExecNode->GetThenPin(), setRenderDepthNodeTrue->GetExecPin());
				Schema->TryCreateConnection(previousFalseExecNode->GetThenPin(), setRenderDepthNodeFalse->GetExecPin());
			}

			//Set the previous set render custom depth nodes to the current set render custom depth nodes
			previousTrueExecNode = setRenderDepthNodeTrue;
			previousFalseExecNode = setRenderDepthNodeFalse;
		
			//Update xPosition
			xPosition += 300;
		}

		//create get all actors of class node
		UK2Node_CallFunction* getAllActorsOfClassNode = Logi::BlueprintUtils::CreateBPGetAllActorsOfClassNode(functionGraph, xPosition, 0);

		//Connect Get all actors of class node to the render custom depth node.
		Schema->TryCreateConnection(previousTrueExecNode->GetThenPin(), getAllActorsOfClassNode->GetExecPin());
		Schema->TryCreateConnection(previousFalseExecNode->GetThenPin(), getAllActorsOfClassNode->GetExecPin());


		//find the actor class pin of the Get all actors of class node
		UEdGraphPin* actorClassPin = getAllActorsOfClassNode->FindPin(FName("ActorClass"));

		//validate the actor class pin
		if (!actorClassPin) {
			UE_LOG(LogTemp, Error, TEXT("Failed to find the actor class pin in the Get All Actors of Class node"));
			return;
		}

		//Find the Logi_ThermalController blueprint
		UBlueprint* controllerBP = Cast<UBlueprint>(StaticLoadObject(UBlueprint::StaticClass(), nullptr, TEXT("/Game/Logi_ThermalCamera/Actors/BP_Logi_ThermalController.BP_Logi_ThermalController")));

		//Validate the thermal controller blueprint
		if (!controllerBP || !controllerBP->GeneratedClass)
		{
			UE_LOG(LogTemp, Error, TEXT("Failed to load BP_Logi_ThermalController or its generated class"));
			return;
		}

		//Set the actor class pin to the BP_Logi_ThermalController class
		actorClassPin->DefaultObject = controllerBP->GeneratedClass;

		//Notify actor class pin that the pin has changed
		actorClassPin->GetSchema()->TrySetDefaultObject(*actorClassPin, controllerBP->GeneratedClass);


		//update xPosition
		xPosition += 300;

		//Create array getter node
		UK2Node_GetArrayItem* arrayGetNode = Logi::BlueprintUtils::CreateBPArrayGetterNode(functionGraph, xPosition, 200);

		//Find the array input pin of the array getter node
		UEdGraphPin* arrayInputPin = arrayGetNode->GetTargetArrayPin();


		//Connect the get all actors of class node to the array getter node
		Schema->TryCreateConnection(getAllActorsOfClassNode->FindPin(FName("OutActors")), arrayInputPin);

		//Notify the array getter node that the input pin has changed to update the pins name to the correct type
		arrayInputPin->GetOwningNode()->PinConnectionListChanged(arrayInputPin);

		//Reconstruct pins for the array getter node to account for the array type
		arrayGetNode->ReconstructNode();


		//Find the index input pin of the array getter node
		UEdGraphPin* indexPin = nullptr;
		//Iterate trough all pins of the getter node
		for (UEdGraphPin* Pin : arrayGetNode->Pins)
		{
			//Check if the pin's direction is an input pin and if the type is an integer, if so it is the index pin.
			if (Pin && Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int && Pin->Direction == EGPD_Input)
			{
				indexPin = Pin;
				break;
			}
		}
		
		//Validate index pin and set the index pins value
		if (indexPin) {
			indexPin->DefaultValue = TEXT("0");
		}
		else {
			UE_LOG(LogTemp, Error, TEXT("Failed to find the index pin in the array getter node"));
			return;
		}

		//Update xPosition
		xPosition += 300;

		//Set thermal controller variable name
		FName thermalControllerVariableName = FName("Logi_ThermalController");

		//Adds thermal controller referense variable
		Logi::BlueprintUtils::AddThermalControlerReferenceToBlueprint(blueprint, thermalControllerVariableName, false);
		
		
		//Create a variable setter node for the Logi_ThermalController variable
		UK2Node_VariableSet* setThermalController = Logi::BlueprintUtils::CreateBPSetterNode(functionGraph, thermalControllerVariableName, xPosition, 0);

		//Connect the array getter node to the setThermalController node
		Schema->TryCreateConnection(arrayGetNode->GetResultPin(), setThermalController->FindPin(thermalControllerVariableName));


		UEdGraphPin* thenPin = getAllActorsOfClassNode->FindPin(UEdGraphSchema_K2::PN_Then);
		if (!thenPin)
		{
			UE_LOG(LogTemp, Error, TEXT("GetAllActorsOfClass node does not have a Then pin!"));
		}

		//Connect the setter node for Logi thermal controller and get all actors of class node's exec pins
		Schema->TryCreateConnection(setThermalController->GetExecPin(), getAllActorsOfClassNode->GetThenPin());

		//Update xPosition
		xPosition += 300;

		//Create dynamic material instance node
		UK2Node_CallFunction* dynamicMaterialInstanceNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceNode(functionGraph, xPosition, 0);

		// Find the parent pin of the dynamic material instance node
		UEdGraphPin* parentPin = dynamicMaterialInstanceNode->FindPin(TEXT("Parent"));

		//Find the Logi_ThermalMaterial
		FString thermalMaterialFilePath = TEXT("/Game/Logi_ThermalCamera/Materials/M_Logi_ThermalMaterial.M_Logi_ThermalMaterial");
		UObject* thermalMaterial = StaticLoadObject(UMaterialInterface::StaticClass(), nullptr, *thermalMaterialFilePath);
		//UMaterialInterface* thermalMaterial = LoadObject<UMaterialInterface>(nullptr, TEXT("/Game/Logi_ThermalCamera/Materials/M_Logi_ThermalMaterial.M_Logi_ThermalMaterial"));

		//Set the parent pin to the logi thermal material
		if (parentPin && thermalMaterial)
		{
			parentPin->DefaultObject = thermalMaterial;
		}

		
		// Connect execution from previous setter
		Schema->TryCreateConnection(setThermalController->GetThenPin(), dynamicMaterialInstanceNode->GetExecPin());

		//Add dynamic material instance variable to blueprint
		FName dynamicMaterialInstanceVariableName = Logi::BlueprintUtils::AddMaterialInstanceVariableToBlueprint(blueprint);

		// Update xPosition
		xPosition += 500;

		//Create a setter node for the dynamic material instance variable
		UK2Node_VariableSet* setDynamicMaterialInstanceNode = Logi::BlueprintUtils::CreateBPSetterNode(functionGraph, dynamicMaterialInstanceVariableName, xPosition, 0);

		//Connect exec pin of the dynamic material instance node to the setter node
		Schema->TryCreateConnection(dynamicMaterialInstanceNode->GetThenPin(), setDynamicMaterialInstanceNode->GetExecPin());

		//Connect the return value of the dynamic material instance node to the setter node
		Schema->TryCreateConnection(dynamicMaterialInstanceNode->FindPin(TEXT("ReturnValue")), setDynamicMaterialInstanceNode->FindPin(dynamicMaterialInstanceVariableName.ToString()));

	}

	void AddNodeSetupToUpdateThermalMaterialFunction(UEdGraph* functionGraph, UK2Node_FunctionEntry* entryNode) {
		//Validate function graph

		if (!functionGraph) {
			UE_LOG(LogTemp, Error, TEXT("Function graph is a nullpointer, cannot add nodes to the graph."));
			return;
		}

		//validate entry node
		if (!entryNode) {
			UE_LOG(LogTemp, Error, TEXT("No function entry node is a nullpointer. Cannot add nodes to the graph."));
			return;
		}

		// Find the function blueprint
		UBlueprint* blueprint = Cast<UBlueprint>(functionGraph->GetOuter());

		//Validate the blueprint
		if (!blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Could not find the blueprint linked to the blueprint function"));
			return;
		}

		//Check every variable in the blueprint for mesh components
		 TArray<USCS_Node*> meshComponents = ActorUtils::FindUscsNodesForMeshComponentsFromABlueprint(blueprint);

		//Check if the meshVariableName is empty if so, skipping implementation.
		if (meshComponents.Num() == 0) {
			UE_LOG(LogTemp, Warning, TEXT("No mesh component found in blueprint '%s', skipping implementation."), *blueprint->GetName());
			return;
		}

		//Get the function graphs schema
		const UEdGraphSchema_K2* Schema = CastChecked<UEdGraphSchema_K2>(functionGraph->GetSchema());

		int xPosition = 300;

		//create branch node for Logi_Hot variable
		UK2Node_IfThenElse* branchNode = Logi::BlueprintUtils::CreateBPBranchNode(functionGraph, xPosition, 0);

		//Create getter for Logi_hot variable
		UK2Node_VariableGet* logiHotGetNode = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_Hot"), xPosition, 200);

		//connect Logi hot getter node to branch nodes condition pin
		branchNode->GetConditionPin()->MakeLinkTo(logiHotGetNode->FindPin(FName("Logi_Hot")));

		//Connect the entry node to the branch node
		Schema->TryCreateConnection(entryNode->FindPin(UEdGraphSchema_K2::PN_Then), branchNode->GetExecPin());

		xPosition += 300;

		//create setter nodes for Logi material index
		UK2Node_VariableSet* setLogiMaterialIndexNodeZero = Logi::BlueprintUtils::CreateBPSetterNode(functionGraph, FName("Logi_MaterialIndex"), xPosition, 100);
		UK2Node_VariableSet* setLogiMaterialIndexNodeOne = Logi::BlueprintUtils::CreateBPSetterNode(functionGraph, FName("Logi_MaterialIndex"), xPosition, -100);

		//set Logi material index pin to 0
		UEdGraphPin* setLogiMaterialIndexNodeZeroPin = setLogiMaterialIndexNodeZero->FindPin(FName("Logi_MaterialIndex"));
		setLogiMaterialIndexNodeZeroPin->DefaultValue = TEXT("0");
		//set Logi material index pin to 1
		UEdGraphPin* setLogiMaterialIndexNodeOnePin = setLogiMaterialIndexNodeOne->FindPin(FName("Logi_MaterialIndex"));
		setLogiMaterialIndexNodeOnePin->DefaultValue = TEXT("1");

		//Connect the branch node to the setter nodes
		Schema->TryCreateConnection(branchNode->GetThenPin(), setLogiMaterialIndexNodeOne->GetExecPin());
		Schema->TryCreateConnection(branchNode->GetElsePin(), setLogiMaterialIndexNodeZero->GetExecPin());

		xPosition += 600;

		//create set scalar parameter value node for CurrentTemperature
		UK2Node_CallFunction* setCurrentTemperatureScalarParameterNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceScalarParameterNode(functionGraph, xPosition, 0);
		setCurrentTemperatureScalarParameterNode->FindPin(FName("ParameterName"))->DefaultValue = TEXT("CurrentTemperature");

		//create getter node for getLogiDynamicMaterialInstance and connect it to the current temperature node
		UK2Node_VariableGet* getLogiLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 300, 100);
		Schema->TryCreateConnection(getLogiLogiDynamicMaterialInstance->GetValuePin(), setCurrentTemperatureScalarParameterNode->FindPin(FName("self")));
		Schema->TryCreateConnection(setLogiMaterialIndexNodeZero->GetThenPin(), setCurrentTemperatureScalarParameterNode->GetExecPin());
		Schema->TryCreateConnection(setLogiMaterialIndexNodeOne->GetThenPin(), setCurrentTemperatureScalarParameterNode->GetExecPin());
		

		//Thermal Controller filepath
		const TCHAR* thermalControllerFilePath = TEXT("/Game/Logi_ThermalCamera/Actors/BP_Logi_ThermalController.BP_Logi_ThermalController_C");

		//create normalize to range node setup for CurrentTemperature
		UK2Node_CallFunction* normalizeToRangeNode = Logi::BlueprintUtils::CreateBPNormalizeToRangeNode(functionGraph, xPosition, 300);
		UK2Node_VariableGet* getLogiCurrentTemperature =  Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_CurrentTemperature"), xPosition - 250, 300);
		Schema->TryCreateConnection(getLogiCurrentTemperature->GetValuePin(), normalizeToRangeNode->FindPin(FName("Value")));
		UK2Node_VariableGet* getThermalController = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_ThermalController"), xPosition - 550, 400);
		UK2Node_VariableGet* getThermalControllerThermalCameraRangeMin = Logi::BlueprintUtils::CreateBPExternalGetterNode(functionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 350);
		UK2Node_VariableGet* getThermalControllerThermalCameraRangeMax = Logi::BlueprintUtils::CreateBPExternalGetterNode(functionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 450);
		
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMin->FindPin(FName("self")));
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMax->FindPin(FName("self")));

		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMin->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMin")));
		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMax->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMax")));
		Schema->TryCreateConnection(normalizeToRangeNode->GetReturnValuePin(), setCurrentTemperatureScalarParameterNode->FindPin(FName("Value")));

		
		xPosition += 800;

		//create set scalar parameter value node for  MaxTemperature node
		UK2Node_CallFunction* setMaxTemperatureScalarParameterNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceScalarParameterNode(functionGraph, xPosition, 0);
		setMaxTemperatureScalarParameterNode->FindPin(FName("ParameterName"))->DefaultValue = TEXT("MaxTemperature");
		Schema->TryCreateConnection(setCurrentTemperatureScalarParameterNode->GetThenPin(), setMaxTemperatureScalarParameterNode->GetExecPin());

		//create normalize to range node setup for MaxTemperature
		normalizeToRangeNode = Logi::BlueprintUtils::CreateBPNormalizeToRangeNode(functionGraph, xPosition, 300);
		UK2Node_VariableGet* getLogiMaxTemperature = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_MaxTemperature"), xPosition - 250, 300);
		Schema->TryCreateConnection(getLogiMaxTemperature->GetValuePin(), normalizeToRangeNode->FindPin(FName("Value")));
		getThermalController = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_ThermalController"), xPosition - 550, 400);
		getThermalControllerThermalCameraRangeMin = Logi::BlueprintUtils::CreateBPExternalGetterNode(functionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 350);
		getThermalControllerThermalCameraRangeMax = Logi::BlueprintUtils::CreateBPExternalGetterNode(functionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 450);

		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMin->FindPin(FName("self")));
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMax->FindPin(FName("self")));

		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMin->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMin")));
		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMax->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMax")));
		Schema->TryCreateConnection(normalizeToRangeNode->GetReturnValuePin(), setMaxTemperatureScalarParameterNode->FindPin(FName("Value")));


		//create getter node for getLogiDynamicMaterialInstance and connect it to the Max temperature node
		getLogiLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 300, 100);
		Schema->TryCreateConnection(getLogiLogiDynamicMaterialInstance->GetValuePin(), setMaxTemperatureScalarParameterNode->FindPin(FName("self")));

		xPosition += 800;

		//create set scalar parameter value node for  BaseTemperature node
		UK2Node_CallFunction* setBaseTemperatureScalarParameterNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceScalarParameterNode(functionGraph, xPosition, 0);
		setBaseTemperatureScalarParameterNode->FindPin(FName("ParameterName"))->DefaultValue = TEXT("BaseTemperature");
		Schema->TryCreateConnection(setMaxTemperatureScalarParameterNode->GetThenPin(), setBaseTemperatureScalarParameterNode->GetExecPin());

		//create normalize to range node setup for MaxTemperature
		normalizeToRangeNode = Logi::BlueprintUtils::CreateBPNormalizeToRangeNode(functionGraph, xPosition, 300);
		UK2Node_VariableGet* getLogiBaseTemperature = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_BaseTemperature"), xPosition - 250, 300);
		Schema->TryCreateConnection(getLogiBaseTemperature->GetValuePin(), normalizeToRangeNode->FindPin(FName("Value")));
		getThermalController = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_ThermalController"), xPosition - 550, 400);
		getThermalControllerThermalCameraRangeMin = Logi::BlueprintUtils::CreateBPExternalGetterNode(functionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 350);
		getThermalControllerThermalCameraRangeMax = Logi::BlueprintUtils::CreateBPExternalGetterNode(functionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 450);

		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMin->FindPin(FName("self")));
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMax->FindPin(FName("self")));

		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMin->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMin")));
		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMax->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMax")));
		Schema->TryCreateConnection(normalizeToRangeNode->GetReturnValuePin(), setBaseTemperatureScalarParameterNode->FindPin(FName("Value")));

		//create getter node for getLogiDynamicMaterialInstance and connect it to the Base temperature node
		getLogiLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 300, 100);
		Schema->TryCreateConnection(getLogiLogiDynamicMaterialInstance->GetValuePin(), setBaseTemperatureScalarParameterNode->FindPin(FName("self")));

		xPosition += 600;

		//Create set material node setup for each mesh component in actor blueprint:
		bool firstLoop = true;
		UK2Node_CallFunction* previousSetMaterialNode = nullptr;
		for (USCS_Node* meshComponent : meshComponents) {
			//Get the mesh component materials:
			TArray<UMaterialInterface*> meshComponentMaterials = ActorUtils::FindAllMaterialsFromActorScsNode(meshComponent);

			int materialIndex = 0;

			//create a set material node for each material in the mesh component
			for (UMaterialInterface* meshComponentMaterial : meshComponentMaterials) {
				//create set material node
				UK2Node_CallFunction* setMaterialNode = Logi::BlueprintUtils::CreateBPSetMaterialNode(functionGraph, xPosition, 0);

				//Create getter node for the mesh component
				UK2Node_VariableGet* meshComponentGetterNode = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, meshComponent->GetVariableName(), xPosition - 150, 100);

				//Connect the mesh component getter node to the Set material node
				Schema->TryCreateConnection(meshComponentGetterNode->GetValuePin(), setMaterialNode->FindPin(FName("self")));

				//Set the material index of the Set Material node
				setMaterialNode->FindPin(FName("ElementIndex"))->DefaultValue = FString::FromInt(materialIndex);

				//Create select node
				UK2Node_Select* selectNode = Logi::BlueprintUtils::CreateBPSelectNode(functionGraph, xPosition, 300);

				//Set the select node's option 0 pin to the mesh component material
				selectNode->FindPin(FName("Option 0"))->DefaultObject = meshComponentMaterial;

				//Create a getter node for the Logi_DynamicMaterialInstance variable
				UK2Node_VariableGet* getLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 250, 300);

				//Connect the Logi_DynamicMaterialInstance getter node to the select node
				Schema->TryCreateConnection(getLogiDynamicMaterialInstance->GetValuePin(), selectNode->FindPin(FName("Option 1")));

				//Connect the setMaterialNode to the select node
				Schema->TryCreateConnection(selectNode->GetReturnValuePin(), setMaterialNode->FindPin(FName("Material")));


				//Create getter node for material index
				UK2Node_VariableGet* materialIndexGetterNode = Logi::BlueprintUtils::CreateBPGetterNode(functionGraph, FName("Logi_MaterialIndex"), xPosition - 150, 600);

				//Connect the material index getter node to the select node
				Schema->TryCreateConnection(materialIndexGetterNode->GetValuePin(), selectNode->FindPin(FName("Index")));

				//Connect the exec pin of the select node to the set material node
				if (firstLoop) {
					Schema->TryCreateConnection(setBaseTemperatureScalarParameterNode->GetThenPin(), setMaterialNode->GetExecPin());
					firstLoop = false;
				}
				else {
					Schema->TryCreateConnection(previousSetMaterialNode->GetThenPin(), setMaterialNode->GetExecPin());
				}

				previousSetMaterialNode = setMaterialNode;

				materialIndex++;
				xPosition += 600;
			}
		}
		

	}

	UEdGraph* AddSetupFunctionToNonLogiActor(const FAssetData& actor) {

		UBlueprint* blueprint = Cast<UBlueprint>(actor.GetAsset());
		FName functionName = FName("Logi_ThermalActorSetup");


		//Validate blueprint
		if (!blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Blueprint is null, cannot add setup function."));
			return nullptr;
		}

		// Check if the setup function already exists in the blueprint
		for (UEdGraph* Graph : blueprint->FunctionGraphs)
		{
			if (Graph && Graph->GetFName() == functionName)
			{
				UE_LOG(LogTemp, Warning, TEXT("Function '%s' already exists in blueprint '%s', skipping implementation."), *functionName.ToString(), *blueprint->GetName());
				return nullptr;
			}
		}


		// Create the setup function
		UEdGraph* newFunctionGraph = FBlueprintEditorUtils::CreateNewGraph(blueprint, functionName, UEdGraph::StaticClass(), UEdGraphSchema_K2::StaticClass());
		FBlueprintEditorUtils::AddFunctionGraph<UFunction>(blueprint, newFunctionGraph,true, nullptr);

		// Find the setup function entry node
		UK2Node_FunctionEntry* entryNode = nullptr;
		for (UEdGraphNode* node : newFunctionGraph->Nodes)
		{
			entryNode = Cast<UK2Node_FunctionEntry>(node);
			if (entryNode)
				break;
		}

		//Mark blueprint as modified
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(blueprint);

		UE_LOG(LogTemp, Log, TEXT("Function 'Logi_ThermalActorSetup' successfully added to blueprint '%s'."), *blueprint->GetName());

		AddNodeSetupToSetupFunction(newFunctionGraph, entryNode);

		return newFunctionGraph;
	}

	UEdGraph* AddUpdateThermalMaterialFunctionToNonLogiActor(const FAssetData& actor) {

		UBlueprint* blueprint = Cast<UBlueprint>(actor.GetAsset());
		FName functionName = FName("Logi_UpdateThermalMaterial");

		//Validate blueprint
		if (!blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Blueprint is null, cannot add setup function."));
			return nullptr;
		}

		// Check if the setup function already exists in the blueprint
		for (UEdGraph* Graph : blueprint->FunctionGraphs)
		{
			if (Graph && Graph->GetFName() == functionName)
			{
				UE_LOG(LogTemp, Warning, TEXT("Function '%s' already exists in blueprint '%s', skipping implementation."), *functionName.ToString(), *blueprint->GetName());
				return nullptr;
			}
		}


		// Create the setup function
		UEdGraph* newFunctionGraph = FBlueprintEditorUtils::CreateNewGraph(blueprint, functionName, UEdGraph::StaticClass(), UEdGraphSchema_K2::StaticClass());
		FBlueprintEditorUtils::AddFunctionGraph<UFunction>(blueprint, newFunctionGraph, true, nullptr);

		// Find the setup function entry node
		UK2Node_FunctionEntry* entryNode = nullptr;
		for (UEdGraphNode* node : newFunctionGraph->Nodes)
		{
			entryNode = Cast<UK2Node_FunctionEntry>(node);
			if (entryNode)
				break;
		}

		//Add node setup to function graph
		AddNodeSetupToUpdateThermalMaterialFunction(newFunctionGraph, entryNode);


		//Mark blueprint as modified
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(blueprint);

		UE_LOG(LogTemp, Log, TEXT("Function 'Logi_ThermalActorSetup' successfully added to blueprint '%s'."), *blueprint->GetName());

		return newFunctionGraph;
	}

	void MakeProjectBPActorsLogiCompatible() {
		//Create a list to hold all the actor blueprints in the project
		TArray<FAssetData> projectActors;
		//Find all the blueprints of type Actor in the /games (content) folder and add them to the projectActors list
		FindAllNonLogiActorBlueprintsInProject(projectActors);

		//Add Logi variables to all the actor blueprints in the project
		for (FAssetData actor : projectActors) {
			//Prints status
			UE_LOG(LogTemp, Warning, TEXT("Adding Logi variables to actor: %s"), *actor.AssetName.ToString());

			//Add Logi variables to the actor blueprint
			AddLogiVariablesToActorBlueprint(actor);
			//Add Logi functions to the actor blueprint
			UEdGraph* setupFunction = AddSetupFunctionToNonLogiActor(actor);
			UEdGraph* updateMaterialFunction = AddUpdateThermalMaterialFunctionToNonLogiActor(actor);

			// Gets and validates the Blueprint
			UBlueprint* blueprint = Cast<UBlueprint>(actor.GetAsset());
			if (!blueprint) {
				UE_LOG(LogTemp, Error, TEXT("Failed to cast actor asset '%s' to Blueprint"), *actor.AssetName.ToString());
				continue;
			}

			// Finds the blueprints event graph
			UEdGraph* eventGraph = nullptr;
			for (UEdGraph* graph : blueprint->UbergraphPages) {
				if (graph && graph->GetFName() == FName(TEXT("EventGraph"))) {
					eventGraph = graph;
					break;
				}
			}

			//Validate the event graph
			if (!eventGraph) {
				UE_LOG(LogTemp, Error, TEXT("No EventGraph found in Blueprint '%s'"), *blueprint->GetName());
				continue;
			}

			//Find the Schema of the event graph
			const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();

			//Validate the schema
			if (!Schema) {
				UE_LOG(LogTemp, Error, TEXT("Failed to get the schema for the EventGraph in Blueprint '%s'"), *blueprint->GetName());
				continue;
			}

			//Check if the Logi_LogiThermalActorSetup function referece nodes already exists in the event graph
			bool logiThermalActorSetupFunctionNodeAlreadyExists = false;
			for (UEdGraphNode* node : eventGraph->Nodes)
			{
				if (UK2Node_CallFunction* callFuncNode = Cast<UK2Node_CallFunction>(node))
				{
					if (callFuncNode->FunctionReference.GetMemberName() == FName("Logi_ThermalActorSetup"))
					{
						logiThermalActorSetupFunctionNodeAlreadyExists = true;
						break;
					}
				}
			}

			//Check if the Logi_UpdateThermalMaterial function referece nodes already exists in the event graph
			bool logiUpdateThermalMaterialFunctionNodeAlreadyExists = false;
			for (UEdGraphNode* node : eventGraph->Nodes)
			{
				if (UK2Node_CallFunction* callFuncNode = Cast<UK2Node_CallFunction>(node))
				{
					if (callFuncNode->FunctionReference.GetMemberName() == FName("Logi_UpdateThermalMaterial"))
					{
						logiUpdateThermalMaterialFunctionNodeAlreadyExists = true;
						break;
					}
				}
			}


			// Add call function for Logi_ThermalActorSetup function to actor blueprint if it does not already exist
			if (!logiThermalActorSetupFunctionNodeAlreadyExists) {
				// Find BeginPlay node
				UK2Node_Event* beginPlayNode = nullptr;
				for (UEdGraphNode* node : eventGraph->Nodes) {
					UK2Node_Event* eventNode = Cast<UK2Node_Event>(node);
					if (eventNode && eventNode->EventReference.GetMemberName() == FName(TEXT("ReceiveBeginPlay"))) {
						beginPlayNode = eventNode;
						break;
					}
				}

				//if the event begin play node is not in the event graph, create it
				if (!beginPlayNode) {
					// If not found, create the BeginPlay event node
					beginPlayNode = NewObject<UK2Node_Event>(eventGraph);
					eventGraph->AddNode(beginPlayNode);
					beginPlayNode->EventReference.SetExternalMember(FName(TEXT("ReceiveBeginPlay")), AActor::StaticClass());
					beginPlayNode->bOverrideFunction = true;
					beginPlayNode->NodePosX = 0;
					beginPlayNode->NodePosY = 0;
					beginPlayNode->AllocateDefaultPins();

					UE_LOG(LogTemp, Warning, TEXT("Created new Event BeginPlay node in Blueprint '%s'"), *blueprint->GetName());
				}

				// Create a call function node to call the Logi_ThermalActorSetup function
				UK2Node_CallFunction* callSetupFunctionNode = Logi::BlueprintUtils::CreateBPCallFunctionNode(eventGraph, FName("Logi_ThermalActorSetup"), beginPlayNode->NodePosX + 200, beginPlayNode->NodePosY);

				//find the begin play node's then pin
				UEdGraphPin* beginPlayThenPin = beginPlayNode->FindPin(UEdGraphSchema_K2::PN_Then);

				//Check if there are nodes already connected to the begin play node
				if (beginPlayThenPin) {
					//Check if the begin play node has any linked nodes, if so make connection between the call function node and the node connected to the begin play node
					if (beginPlayThenPin->LinkedTo.Num() > 0) {
						//Find the pin connected to the begin play node
						UEdGraphPin* originalConnectedPin = beginPlayThenPin->LinkedTo[0];

						//Break connection between begin play node and the node connected to it
						Schema->BreakPinLinks(*beginPlayThenPin, false);

						//connect the begin play node to the call function node
						Schema->TryCreateConnection(callSetupFunctionNode->GetThenPin(), originalConnectedPin);

						//Connect beginplaynode to the call function node
						Schema->TryCreateConnection(beginPlayThenPin, callSetupFunctionNode->GetExecPin());

					}
					else {
						Schema->TryCreateConnection(beginPlayThenPin, callSetupFunctionNode->GetExecPin());
					}
				}
			}

			// Create a call function node to call the Logi_UpdateThermalMaterial function
			if (!logiUpdateThermalMaterialFunctionNodeAlreadyExists) {

				// Find EventTick node
				UK2Node_Event* eventTickNode = nullptr;
				for (UEdGraphNode* node : eventGraph->Nodes) {
					UK2Node_Event* eventNode = Cast<UK2Node_Event>(node);
					if (eventNode && eventNode->EventReference.GetMemberName() == FName(TEXT("ReceiveTick"))) {
						eventTickNode = eventNode;
						break;
					}
				}

				//if the event begin play node is not in the event graph, create it
				if (!eventTickNode) {
					// If not found, create the BeginPlay event node
					eventTickNode = NewObject<UK2Node_Event>(eventGraph);
					eventGraph->AddNode(eventTickNode);
					eventTickNode->EventReference.SetExternalMember(FName(TEXT("ReceiveTick")), AActor::StaticClass());
					eventTickNode->bOverrideFunction = true;
					eventTickNode->NodePosX = 0;
					eventTickNode->NodePosY = 0;
					eventTickNode->AllocateDefaultPins();

					UE_LOG(LogTemp, Warning, TEXT("Created new Event eventTickNode node in Blueprint '%s'"), *blueprint->GetName());
				}

				//find the eventTick node's then and value pin
				UEdGraphPin* eventTickThenPin = eventTickNode->FindPin(UEdGraphSchema_K2::PN_Then);
				UEdGraphPin* eventTickValuePin = eventTickNode->FindPin(FName("DeltaSeconds"));

				// Create a call function node to call the Logi_ThermalActorSetup function
				UK2Node_CallFunction* callUpdateThermalMaterialNode= Logi::BlueprintUtils::CreateBPCallFunctionNode(eventGraph, FName("Logi_UpdateThermalMaterial"), eventTickNode->NodePosX + 200, eventTickNode->NodePosY);

				//Check if there are nodes already connected to the event tick node
				if (eventTickThenPin) {
					//Check if the event tick has any linked nodes, if so make connection between the call function node and the node connected to the event tick node
					if (eventTickThenPin->LinkedTo.Num() > 0) {
						//Find the pin connected to the begin play node
						UEdGraphPin* originalConnectedPin = eventTickThenPin->LinkedTo[0];

						//Break connection between begin play node and the node connected to it
						Schema->BreakPinLinks(*eventTickThenPin, false);

						//connect the begin play node to the call function node
						Schema->TryCreateConnection(callUpdateThermalMaterialNode->GetThenPin(), originalConnectedPin);

						//Connect beginplaynode to the call function node
						Schema->TryCreateConnection(eventTickThenPin, callUpdateThermalMaterialNode->GetExecPin());
					}
					else {
						Schema->TryCreateConnection(eventTickThenPin, callUpdateThermalMaterialNode->GetExecPin());
					}
				}
			}
			
		}
	}

}
