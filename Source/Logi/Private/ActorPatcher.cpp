#include "ActorPatcher.h"

#include "K2Node_CallFunction.h"
#include "K2Node_Event.h"
#include "K2Node_FunctionEntry.h"
#include "K2Node_Select.h"
#include "MaterialDomain.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "Utils/ActorUtils.h"
#include "Utils/BlueprintUtils.h"


namespace Logi::ActorPatcher
{
	// Creates Thermal Material on already existing material of the actor(?)
	void CreateThermalMaterial(bool& bSuccess, FString& StatusMessage) {
		#if WITH_EDITOR
			bSuccess = false;

			//Load the thermal material function
			UMaterialFunctionInterface* ThermalMaterialFunction = LoadObject<UMaterialFunctionInterface>(nullptr, TEXT("/Game/Logi_ThermalCamera/Materials/MF_Logi_ThermalMaterialFunction.MF_Logi_ThermalMaterialFunction"));

			//Check if the function was loaded successfully
			if (!ThermalMaterialFunction) {
				StatusMessage = TEXT("Failed to load MF_Logi_ThermalMaterialFunction in CreateThermalMaterial. Thermal material could not be created.");
				return;
			}

			// Define names, paths and packages
			const FString MaterialName = TEXT("M_Logi_ThermalMaterial");
			const FString PackagePath = TEXT("/Game/Logi_ThermalCamera/Materials/");
			const FString MaterialPath = PackagePath + MaterialName;
			UPackage* Package = CreatePackage(*MaterialPath);

			if (!Package)
			{
				StatusMessage = TEXT("Failed to create Package in CreateThermalMaterial. Thermal material could not be created.");
				return;
			}

			//Create the material
			UMaterial* Material = NewObject<UMaterial>(Package, *MaterialName, RF_Public | RF_Standalone);

			if (!Material)
			{
				StatusMessage = TEXT("Failed to create material in CreateThermalMaterial. Thermal material could not be created.");
				return;
			}

			// Set material properties
			Material->MaterialDomain = MD_Surface;
			Material->BlendMode = BLEND_Opaque;
			Material->SetShadingModel(MSM_DefaultLit);
			Material->bUseMaterialAttributes = true;

			// Create a node for the MF_Logi_ThermalMaterialFunction
			UMaterialExpressionMaterialFunctionCall* FunctionCall = NewObject<UMaterialExpressionMaterialFunctionCall>(Material);
			FunctionCall->Material = Material;
			FunctionCall->SetMaterialFunction(ThermalMaterialFunction);
			FunctionCall->UpdateFromFunctionResource();
			FunctionCall->MaterialExpressionEditorX = -400;
			FunctionCall->MaterialExpressionEditorY = 0;

			//Connecdt the MF_Logi_ThermalMaterialFunction to the materials output node
			Material->GetEditorOnlyData()->MaterialAttributes.Expression = FunctionCall;

			// Add the expression to the material
			Material->GetEditorOnlyData()->ExpressionCollection.Expressions.Add(FunctionCall);

			// Mark the material as edited
			Material->PreEditChange(nullptr);
			Material->PostEditChange();
			Material->MarkPackageDirty();

			//Register the material in the asset registry
			FAssetRegistryModule::AssetCreated(Material);

			// Save the material
			const FString filePath = FPackageName::LongPackageNameToFilename(MaterialPath, FPackageName::GetAssetPackageExtension());

			if (!UPackage::SavePackage(Package, Material, EObjectFlags::RF_Public | RF_Standalone, *filePath))
			{
				StatusMessage = TEXT("Failed to save the material package in CreateThermalMaterial. Could not create thermal material.");
				return;
			}

			bSuccess = true;
			StatusMessage = TEXT("Successfully created thermal material.");

		#else
			success = false;
			statusMessage = TEXT("The function CreateThermalMaterial can only be run in editor builds");
		#endif
	}

	// Finds all Actor blueprints in the project, that are not Logi-created
	void FindAllNonLogiActorBlueprintsInProject(TArray<FAssetData>& OutActorBlueprints) {
		//Get the asset registry module
		const FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>("AssetRegistry");

		//Get the asset registry inside the asset registry module
		IAssetRegistry& Registry = AssetRegistryModule.Get();

		// verify registry is up to date
		Registry.SearchAllAssets(true);

		// Create filert for the search
		FARFilter Filter;
		Filter.ClassPaths.Add(UBlueprint::StaticClass()->GetClassPathName());
		Filter.PackagePaths.Add(FName("/Game"));
		Filter.bRecursivePaths = true;

		//create array to hold blueprints found
		TArray<FAssetData> AssetList;

		//Get all blueprints in the /games (content) folder and add them to the AssetsList list
		Registry.GetAssets(Filter, AssetList);

		//Filter out all blueprints that are not actors
		for (const FAssetData& Asset : AssetList) {

			// Skipping the Logi_ThermalCamera folder
			if (Asset.PackagePath.ToString().StartsWith("/Game/Logi_ThermalCamera")) {
				continue;
			}

			//Check if the blueprint has a parent class
			FString ParentClassPath;

			//Get the parent class path and set it to the ParentClassPath variable to that path
			if (Asset.GetTagValue<FString>("ParentClass", ParentClassPath))
			{
				// Remove the autogenerated "_C" suffix from the class path
				ParentClassPath.RemoveFromEnd(TEXT("_C"), ESearchCase::IgnoreCase);

				//Tries to find the actualparent class object from the classe's path
				const UClass* ParentClass = FindObject<UClass>(nullptr, *ParentClassPath);

				//Check if the parent class is a child of the AActor, i.e. if it's an Actor blueprint
				if (ParentClass && ParentClass->IsChildOf(AActor::StaticClass()))
				{
					//Actor blueprint added to the list
					OutActorBlueprints.Add(Asset);
				}
			}
		}
	}

	void AddLogiVariablesToActorBlueprint(const FAssetData& Actor) {

		//Cast asset data to blueprint type
		UBlueprint* Blueprint = Cast<UBlueprint>(Actor.GetAsset());

		//Validate that the cast was successfull
		if(!Blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Failed to load blueprint from asset data: %s"), *Actor.AssetName.ToString());
			return;
		}

		//Create bolean type
		FEdGraphPinType BoolType;
		BoolType.PinCategory = UEdGraphSchema_K2::PC_Boolean;

		//Create float type
		FEdGraphPinType FloatType;
		FloatType.PinCategory = UEdGraphSchema_K2::PC_Real;
		FloatType.PinSubCategory = UEdGraphSchema_K2::PC_Float;

		//Create index type
		FEdGraphPinType INTType;
		INTType.PinCategory = UEdGraphSchema_K2::PC_Int;

		//Create Linear Color type
		FEdGraphPinType linearColorType;
		linearColorType.PinCategory = UEdGraphSchema_K2::PC_Struct;
		linearColorType.PinSubCategoryObject = TBaseStructure<FLinearColor>::Get();

		//Create vector type
		FEdGraphPinType VectorType;
		VectorType.PinCategory = UEdGraphSchema_K2::PC_Struct;
		VectorType.PinSubCategoryObject = TBaseStructure<FVector>::Get();

		//Print status
		UE_LOG(LogTemp, Warning, TEXT("Adding variable to actor blueprint"));

		//Add variables to the blueprint
		Logi::BlueprintUtils::AddVariableToBlueprintClass(Blueprint, "Logi_Hot", BoolType, true, "false");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(Blueprint, "Logi_BaseTemperature", FloatType, true, "0.0");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(Blueprint, "Logi_MaxTemperature", FloatType, true, "25.0");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(Blueprint, "Logi_CurrentTemperature", FloatType, true, "25.0");
		Logi::BlueprintUtils::AddVariableToBlueprintClass(Blueprint, "Logi_MaterialIndex", INTType, false, "0");
	}

	void AddNodeSetupToSetupFunction(UEdGraph* FunctionGraph, const UK2Node_FunctionEntry* EntryNode) {
		//Validate function graph

		if (!FunctionGraph) {
			UE_LOG(LogTemp, Error, TEXT("Function graph is a nullpointer, cannot add nodes to the graph."));
			return;
		}

		//validate entry node
		if (!EntryNode) {
			UE_LOG(LogTemp, Error, TEXT("No function entry node is a nullpointer. Cannot add nodes to the graph."));
			return;
		}

		// Find the function blueprint
		UBlueprint* Blueprint = Cast<UBlueprint>(FunctionGraph->GetOuter());

		//Validate the blueprint
		if (!Blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Could not find the blueprint linked to the blueprint function"));
			return;
		}

		int XPosition = 300;

		//Check every variable in the blueprint for mesh components
		TArray<FName> MeshComponentNames = ActorUtils::FindAllMeshComponentsInBlueprint(Blueprint);

		//Check if the meshVariableName is empty if so, skipping implementation.
		if (MeshComponentNames.Num() == 0) {
			UE_LOG(LogTemp, Warning, TEXT("No skeletal mesh component found in blueprint '%s', skipping implementation."), *Blueprint->GetName());
			return;
		}

		//Get the function graphs schema
		const UEdGraphSchema_K2* Schema = CastChecked<UEdGraphSchema_K2>(FunctionGraph->GetSchema());

		//Create Logi_Hot variable getter node
		const UK2Node_VariableGet* LogiHotGetNode = BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_Hot"), XPosition, 200);

		//Update xPosition
		XPosition += 100;

		//Creating nodes inside the function graph
		const UK2Node_IfThenElse* BranchNode = BlueprintUtils::CreateBPBranchNode(FunctionGraph, XPosition, 0);

		//Update xPosition
		XPosition += 300;

		//Connect the entry node to the branch node
		UEdGraphPin* ExecPin = EntryNode->FindPin(UEdGraphSchema_K2::PN_Then);

		//Connect the Logi_Hot variable getter node to the branch node
		Schema->TryCreateConnection(LogiHotGetNode->FindPin(FName("Logi_Hot")), BranchNode->GetConditionPin());

		//Connect the entry node to the branch node
		Schema->TryCreateConnection(ExecPin, BranchNode->GetExecPin());

		// Pointers to track the last SetRenderCustomDepth node in the true/false chain
		const UK2Node_CallFunction* PreviousTrueExecNode = nullptr;
		const UK2Node_CallFunction* PreviousFalseExecNode = nullptr;

		//Create mesh getter nodes and set render custom deapth node for each mesh in the blueprint
		for (int32 i = 0; i < MeshComponentNames.Num(); ++i) {

			//Get the mesh variable name
			FName MeshVariableName = MeshComponentNames[i];

			//Create mesh getter nodes
			const UK2Node_VariableGet* MeshGetterNodeTrue = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, MeshVariableName, XPosition, -400);
			const UK2Node_VariableGet* MeshGetterNodeFalse = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, MeshVariableName, XPosition, 500);

			//Create set render custom depth nodes
			UK2Node_CallFunction* SetRenderDepthNodeTrue = Logi::BlueprintUtils::CreateBPSetRenderDepthNode(FunctionGraph, true, XPosition, -200);
			UK2Node_CallFunction* SetRenderDepthNodeFalse = Logi::BlueprintUtils::CreateBPSetRenderDepthNode(FunctionGraph, false, XPosition, 200);

			//Try to find the target pin for the set render custom depth nodes
			UEdGraphPin* TrueTargetPin = SetRenderDepthNodeTrue->FindPin(UEdGraphSchema_K2::PN_Self);
			UEdGraphPin* FalseTargetPin = SetRenderDepthNodeFalse->FindPin(UEdGraphSchema_K2::PN_Self);

			//Connect mesh getter nodes to set render custom depth nodes
			if (TrueTargetPin && MeshGetterNodeTrue->GetValuePin()) {
				Schema->TryCreateConnection(MeshGetterNodeTrue->GetValuePin(), TrueTargetPin);
			}

			if (FalseTargetPin && MeshGetterNodeFalse->GetValuePin()) {
				Schema->TryCreateConnection(MeshGetterNodeFalse->GetValuePin(), FalseTargetPin);
			}

			//Check if this is the first set render custom depth node in the chains
			if (i == 0) {
				//Connect the branch node to the set render custom depth nodes
				Schema->TryCreateConnection(BranchNode->GetThenPin(), SetRenderDepthNodeTrue->GetExecPin());
				Schema->TryCreateConnection(BranchNode->GetElsePin(), SetRenderDepthNodeFalse->GetExecPin());

				//Set the previous set render custom depth nodes to the current set render custom depth nodes
			}
			else {
				//Connect the previous set render custom depth node to the current set render custom depth node
				Schema->TryCreateConnection(PreviousTrueExecNode->GetThenPin(), SetRenderDepthNodeTrue->GetExecPin());
				Schema->TryCreateConnection(PreviousFalseExecNode->GetThenPin(), SetRenderDepthNodeFalse->GetExecPin());
			}

			//Set the previous set render custom depth nodes to the current set render custom depth nodes
			PreviousTrueExecNode = SetRenderDepthNodeTrue;
			PreviousFalseExecNode = SetRenderDepthNodeFalse;
		
			//Update xPosition
			XPosition += 300;
		}

		//create get all actors of class node
		const UK2Node_CallFunction* GetAllActorsOfClassNode = Logi::BlueprintUtils::CreateBPGetAllActorsOfClassNode(FunctionGraph, XPosition, 0);

		//Connect Get all actors of class node to the render custom depth node.
		Schema->TryCreateConnection(PreviousTrueExecNode->GetThenPin(), GetAllActorsOfClassNode->GetExecPin());
		Schema->TryCreateConnection(PreviousFalseExecNode->GetThenPin(), GetAllActorsOfClassNode->GetExecPin());


		//find the actor class pin of the Get all actors of class node
		UEdGraphPin* actorClassPin = GetAllActorsOfClassNode->FindPin(FName("ActorClass"));

		//validate the actor class pin
		if (!actorClassPin) {
			UE_LOG(LogTemp, Error, TEXT("Failed to find the actor class pin in the Get All Actors of Class node"));
			return;
		}

		//Find the Logi_ThermalController blueprint
		UBlueprint* ControllerBP = Cast<UBlueprint>(StaticLoadObject(UBlueprint::StaticClass(), nullptr, TEXT("/Game/Logi_ThermalCamera/Actors/BP_Logi_ThermalController.BP_Logi_ThermalController")));

		//Validate the thermal controller blueprint
		if (!ControllerBP || !ControllerBP->GeneratedClass)
		{
			UE_LOG(LogTemp, Error, TEXT("Failed to load BP_Logi_ThermalController or its generated class"));
			return;
		}

		//Set the actor class pin to the BP_Logi_ThermalController class
		actorClassPin->DefaultObject = ControllerBP->GeneratedClass;

		//Notify actor class pin that the pin has changed
		actorClassPin->GetSchema()->TrySetDefaultObject(*actorClassPin, ControllerBP->GeneratedClass);


		//update xPosition
		XPosition += 300;

		//Create array getter node
		UK2Node_GetArrayItem* ArrayGetNode = Logi::BlueprintUtils::CreateBPArrayGetterNode(FunctionGraph, XPosition, 200);

		//Find the array input pin of the array getter node
		UEdGraphPin* ArrayInputPin = ArrayGetNode->GetTargetArrayPin();


		//Connect the get all actors of class node to the array getter node
		Schema->TryCreateConnection(GetAllActorsOfClassNode->FindPin(FName("OutActors")), ArrayInputPin);

		//Notify the array getter node that the input pin has changed to update the pins name to the correct type
		ArrayInputPin->GetOwningNode()->PinConnectionListChanged(ArrayInputPin);

		//Reconstruct pins for the array getter node to account for the array type
		ArrayGetNode->ReconstructNode();


		//Find the index input pin of the array getter node
		UEdGraphPin* IndexPin = nullptr;
		//Iterate through all pins of the getter node
		for (UEdGraphPin* Pin : ArrayGetNode->Pins)
		{
			//Check if the pin's direction is an input pin and if the type is an integer, if so it is the index pin.
			if (Pin && Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Int && Pin->Direction == EGPD_Input)
			{
				IndexPin = Pin;
				break;
			}
		}
		
		//Validate index pin and set the index pins value
		if (IndexPin) {
			IndexPin->DefaultValue = TEXT("0");
		}
		else {
			UE_LOG(LogTemp, Error, TEXT("Failed to find the index pin in the array getter node"));
			return;
		}

		//Update xPosition
		XPosition += 300;

		//Set thermal controller variable name
		const FName ThermalControllerVariableName = FName("Logi_ThermalController");

		//Adds thermal controller referense variable
		Logi::BlueprintUtils::AddThermalControllerReferenceToBlueprint(Blueprint, ThermalControllerVariableName, false);
		
		
		//Create a variable setter node for the Logi_ThermalController variable
		const UK2Node_VariableSet* SetThermalController = Logi::BlueprintUtils::CreateBPSetterNode(FunctionGraph, ThermalControllerVariableName, XPosition, 0);

		//Connect the array getter node to the setThermalController node
		Schema->TryCreateConnection(ArrayGetNode->GetResultPin(), SetThermalController->FindPin(ThermalControllerVariableName));


		const UEdGraphPin* ThenPin = GetAllActorsOfClassNode->FindPin(UEdGraphSchema_K2::PN_Then);
		if (!ThenPin)
		{
			UE_LOG(LogTemp, Error, TEXT("GetAllActorsOfClass node does not have a Then pin!"));
		}

		//Connect the setter node for Logi thermal controller and get all actors of class node's exec pins
		Schema->TryCreateConnection(SetThermalController->GetExecPin(), GetAllActorsOfClassNode->GetThenPin());

		//Update xPosition
		XPosition += 300;

		//Create dynamic material instance node
		const UK2Node_CallFunction* DynamicMaterialInstanceNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceNode(FunctionGraph, XPosition, 0);

		// Find the parent pin of the dynamic material instance node
		UEdGraphPin* ParentPin = DynamicMaterialInstanceNode->FindPin(TEXT("Parent"));

		//Find the Logi_ThermalMaterial
		const FString ThermalMaterialFilePath = TEXT("/Game/Logi_ThermalCamera/Materials/M_Logi_ThermalMaterial.M_Logi_ThermalMaterial");
		UObject* ThermalMaterial = StaticLoadObject(UMaterialInterface::StaticClass(), nullptr, *ThermalMaterialFilePath);
		//UMaterialInterface* thermalMaterial = LoadObject<UMaterialInterface>(nullptr, TEXT("/Game/Logi_ThermalCamera/Materials/M_Logi_ThermalMaterial.M_Logi_ThermalMaterial"));

		//Set the parent pin to the logi thermal material
		if (ParentPin && ThermalMaterial)
		{
			ParentPin->DefaultObject = ThermalMaterial;
		}

		
		// Connect execution from previous setter
		Schema->TryCreateConnection(SetThermalController->GetThenPin(), DynamicMaterialInstanceNode->GetExecPin());

		//Add dynamic material instance variable to blueprint
		const FName DynamicMaterialInstanceVariableName = Logi::BlueprintUtils::AddMaterialInstanceVariableToBlueprint(Blueprint);

		// Update xPosition
		XPosition += 500;

		//Create a setter node for the dynamic material instance variable
		const UK2Node_VariableSet* SetDynamicMaterialInstanceNode = Logi::BlueprintUtils::CreateBPSetterNode(FunctionGraph, DynamicMaterialInstanceVariableName, XPosition, 0);

		//Connect exec pin of the dynamic material instance node to the setter node
		Schema->TryCreateConnection(DynamicMaterialInstanceNode->GetThenPin(), SetDynamicMaterialInstanceNode->GetExecPin());

		//Connect the return value of the dynamic material instance node to the setter node
		Schema->TryCreateConnection(DynamicMaterialInstanceNode->FindPin(TEXT("ReturnValue")), SetDynamicMaterialInstanceNode->FindPin(DynamicMaterialInstanceVariableName.ToString()));

	}

	void AddNodeSetupToUpdateThermalMaterialFunction(UEdGraph* FunctionGraph, const UK2Node_FunctionEntry* EntryNode) {
		//Validate function graph

		if (!FunctionGraph) {
			UE_LOG(LogTemp, Error, TEXT("Function graph is a nullpointer, cannot add nodes to the graph."));
			return;
		}

		//validate entry node
		if (!EntryNode) {
			UE_LOG(LogTemp, Error, TEXT("No function entry node is a nullpointer. Cannot add nodes to the graph."));
			return;
		}

		// Find the function blueprint
		const UBlueprint* blueprint = Cast<UBlueprint>(FunctionGraph->GetOuter());

		//Validate the blueprint
		if (!blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Could not find the blueprint linked to the blueprint function"));
			return;
		}

		//Check every variable in the blueprint for mesh components
		 TArray<USCS_Node*> meshComponents = ActorUtils::FindUscsNodesForMeshComponentsFromBlueprint(blueprint);

		//Check if the meshVariableName is empty if so, skipping implementation.
		if (meshComponents.Num() == 0) {
			UE_LOG(LogTemp, Warning, TEXT("No mesh component found in blueprint '%s', skipping implementation."), *blueprint->GetName());
			return;
		}

		//Get the function graphs schema
		const UEdGraphSchema_K2* Schema = CastChecked<UEdGraphSchema_K2>(FunctionGraph->GetSchema());

		int xPosition = 300;

		//create branch node for ThermalControllerActive variable
		const UK2Node_IfThenElse* branchNode = Logi::BlueprintUtils::CreateBPBranchNode(FunctionGraph, xPosition, 0);

		//Thermal Controller filepath
		const TCHAR* thermalControllerFilePath = TEXT("/Game/Logi_ThermalCamera/Actors/BP_Logi_ThermalController.BP_Logi_ThermalController_C");


		//Get Thermal Controllers ThermalCameraActive variable
		const UK2Node_VariableGet* getThermalController = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_ThermalController"), xPosition - 500, 200);
		const UK2Node_VariableGet* getThermalControllerThermalCameraActive = Logi::BlueprintUtils::CreateBPExternalGetterNode(FunctionGraph, FName("ThermalCameraActive"), thermalControllerFilePath, xPosition - 300,200);

		//Connect ThermalController getter node to the external getter node
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraActive->FindPin(FName("self")));

		//connect ThermalControllerActive getter node to branch nodes condition pin
		branchNode->GetConditionPin()->MakeLinkTo(getThermalControllerThermalCameraActive->FindPin(FName("ThermalCameraActive")));

		//Connect the entry node to the branch node
		Schema->TryCreateConnection(EntryNode->FindPin(UEdGraphSchema_K2::PN_Then), branchNode->GetExecPin());

		xPosition += 300;

		//create setter nodes for Logi material index
		const UK2Node_VariableSet* setLogiMaterialIndexNodeZero = Logi::BlueprintUtils::CreateBPSetterNode(FunctionGraph, FName("Logi_MaterialIndex"), xPosition, 100);
		const UK2Node_VariableSet* setLogiMaterialIndexNodeOne = Logi::BlueprintUtils::CreateBPSetterNode(FunctionGraph, FName("Logi_MaterialIndex"), xPosition, -100);

		//set Logi material index pin to 0
		UEdGraphPin* setLogiMaterialIndexNodeZeroPin = setLogiMaterialIndexNodeZero->FindPin(FName("Logi_MaterialIndex"));
		setLogiMaterialIndexNodeZeroPin->DefaultValue = TEXT("0");
		//set Logi material index pin to 1
		UEdGraphPin* setLogiMaterialIndexNodeOnePin = setLogiMaterialIndexNodeOne->FindPin(FName("Logi_MaterialIndex"));
		setLogiMaterialIndexNodeOnePin->DefaultValue = TEXT("1");

		//Connect the branch node to the setter nodes
		Schema->TryCreateConnection(branchNode->GetThenPin(), setLogiMaterialIndexNodeOne->GetExecPin());
		Schema->TryCreateConnection(branchNode->GetElsePin(), setLogiMaterialIndexNodeZero->GetExecPin());

		xPosition += 600;

		//create set scalar parameter value node for CurrentTemperature
		const UK2Node_CallFunction* setCurrentTemperatureScalarParameterNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceScalarParameterNode(FunctionGraph, xPosition, 0);
		setCurrentTemperatureScalarParameterNode->FindPin(FName("ParameterName"))->DefaultValue = TEXT("CurrentTemperature");

		//create getter node for getLogiDynamicMaterialInstance and connect it to the current temperature node
		const UK2Node_VariableGet* getLogiLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 300, 100);
		Schema->TryCreateConnection(getLogiLogiDynamicMaterialInstance->GetValuePin(), setCurrentTemperatureScalarParameterNode->FindPin(FName("self")));
		Schema->TryCreateConnection(setLogiMaterialIndexNodeZero->GetThenPin(), setCurrentTemperatureScalarParameterNode->GetExecPin());
		Schema->TryCreateConnection(setLogiMaterialIndexNodeOne->GetThenPin(), setCurrentTemperatureScalarParameterNode->GetExecPin());
		
		//create normalize to range node setup for CurrentTemperature
		const UK2Node_CallFunction* normalizeToRangeNode = Logi::BlueprintUtils::CreateBPNormalizeToRangeNode(FunctionGraph, xPosition, 300);
		const UK2Node_VariableGet* getLogiCurrentTemperature =  Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_CurrentTemperature"), xPosition - 250, 300);
		Schema->TryCreateConnection(getLogiCurrentTemperature->GetValuePin(), normalizeToRangeNode->FindPin(FName("Value")));
		getThermalController = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_ThermalController"), xPosition - 550, 400);
		const UK2Node_VariableGet* getThermalControllerThermalCameraRangeMin = Logi::BlueprintUtils::CreateBPExternalGetterNode(FunctionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 350);
		const UK2Node_VariableGet* getThermalControllerThermalCameraRangeMax = Logi::BlueprintUtils::CreateBPExternalGetterNode(FunctionGraph, FName("ThermalCameraRangeMax"), thermalControllerFilePath, xPosition - 300, 450);
		
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMin->FindPin(FName("self")));
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMax->FindPin(FName("self")));

		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMin->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMin")));
		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMax->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMax")));
		Schema->TryCreateConnection(normalizeToRangeNode->GetReturnValuePin(), setCurrentTemperatureScalarParameterNode->FindPin(FName("Value")));

		
		xPosition += 800;

		//create set scalar parameter value node for  MaxTemperature node
		const UK2Node_CallFunction* setMaxTemperatureScalarParameterNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceScalarParameterNode(FunctionGraph, xPosition, 0);
		setMaxTemperatureScalarParameterNode->FindPin(FName("ParameterName"))->DefaultValue = TEXT("MaxTemperature");
		Schema->TryCreateConnection(setCurrentTemperatureScalarParameterNode->GetThenPin(), setMaxTemperatureScalarParameterNode->GetExecPin());

		//create normalize to range node setup for MaxTemperature
		normalizeToRangeNode = Logi::BlueprintUtils::CreateBPNormalizeToRangeNode(FunctionGraph, xPosition, 300);
		const UK2Node_VariableGet* getLogiMaxTemperature = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_MaxTemperature"), xPosition - 250, 300);
		Schema->TryCreateConnection(getLogiMaxTemperature->GetValuePin(), normalizeToRangeNode->FindPin(FName("Value")));
		getThermalController = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_ThermalController"), xPosition - 550, 400);
		getThermalControllerThermalCameraRangeMin = Logi::BlueprintUtils::CreateBPExternalGetterNode(FunctionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 350);
		getThermalControllerThermalCameraRangeMax = Logi::BlueprintUtils::CreateBPExternalGetterNode(FunctionGraph, FName("ThermalCameraRangeMax"), thermalControllerFilePath, xPosition - 300, 450);

		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMin->FindPin(FName("self")));
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMax->FindPin(FName("self")));

		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMin->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMin")));
		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMax->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMax")));
		Schema->TryCreateConnection(normalizeToRangeNode->GetReturnValuePin(), setMaxTemperatureScalarParameterNode->FindPin(FName("Value")));


		//create getter node for getLogiDynamicMaterialInstance and connect it to the Max temperature node
		getLogiLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 300, 100);
		Schema->TryCreateConnection(getLogiLogiDynamicMaterialInstance->GetValuePin(), setMaxTemperatureScalarParameterNode->FindPin(FName("self")));

		xPosition += 800;

		//create set scalar parameter value node for  BaseTemperature node
		const UK2Node_CallFunction* setBaseTemperatureScalarParameterNode = Logi::BlueprintUtils::CreateBPDynamicMaterialInstanceScalarParameterNode(FunctionGraph, xPosition, 0);
		setBaseTemperatureScalarParameterNode->FindPin(FName("ParameterName"))->DefaultValue = TEXT("BaseTemperature");
		Schema->TryCreateConnection(setMaxTemperatureScalarParameterNode->GetThenPin(), setBaseTemperatureScalarParameterNode->GetExecPin());

		//create normalize to range node setup for MaxTemperature
		normalizeToRangeNode = Logi::BlueprintUtils::CreateBPNormalizeToRangeNode(FunctionGraph, xPosition, 300);
		const UK2Node_VariableGet* getLogiBaseTemperature = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_BaseTemperature"), xPosition - 250, 300);
		Schema->TryCreateConnection(getLogiBaseTemperature->GetValuePin(), normalizeToRangeNode->FindPin(FName("Value")));
		getThermalController = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_ThermalController"), xPosition - 550, 400);
		getThermalControllerThermalCameraRangeMin = Logi::BlueprintUtils::CreateBPExternalGetterNode(FunctionGraph, FName("ThermalCameraRangeMin"), thermalControllerFilePath, xPosition - 300, 350);
		getThermalControllerThermalCameraRangeMax = Logi::BlueprintUtils::CreateBPExternalGetterNode(FunctionGraph, FName("ThermalCameraRangeMax"), thermalControllerFilePath, xPosition - 300, 450);

		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMin->FindPin(FName("self")));
		Schema->TryCreateConnection(getThermalController->GetValuePin(), getThermalControllerThermalCameraRangeMax->FindPin(FName("self")));

		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMin->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMin")));
		Schema->TryCreateConnection(getThermalControllerThermalCameraRangeMax->GetValuePin(), normalizeToRangeNode->FindPin(FName("RangeMax")));
		Schema->TryCreateConnection(normalizeToRangeNode->GetReturnValuePin(), setBaseTemperatureScalarParameterNode->FindPin(FName("Value")));

		//create getter node for getLogiDynamicMaterialInstance and connect it to the Base temperature node
		getLogiLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 300, 100);
		Schema->TryCreateConnection(getLogiLogiDynamicMaterialInstance->GetValuePin(), setBaseTemperatureScalarParameterNode->FindPin(FName("self")));

		xPosition += 600;

		//Create set material node setup for each mesh component in actor blueprint:
		bool firstLoop = true;
		const UK2Node_CallFunction* previousSetMaterialNode = nullptr;
		for (const USCS_Node* meshComponent : meshComponents) {
			//Get the mesh component materials:
			TArray<UMaterialInterface*> meshComponentMaterials = ActorUtils::FindAllMaterialsFromActorScsNode(meshComponent);

			int materialIndex = 0;

			//create a set material node for each material in the mesh component
			for (UMaterialInterface* meshComponentMaterial : meshComponentMaterials) {
				//create set material node
				UK2Node_CallFunction* setMaterialNode = Logi::BlueprintUtils::CreateBPSetMaterialNode(FunctionGraph, xPosition, 0);

				//Create getter node for the mesh component
				const UK2Node_VariableGet* meshComponentGetterNode = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, meshComponent->GetVariableName(), xPosition - 150, 100);

				//Connect the mesh component getter node to the Set material node
				Schema->TryCreateConnection(meshComponentGetterNode->GetValuePin(), setMaterialNode->FindPin(FName("self")));

				//Set the material index of the Set Material node
				setMaterialNode->FindPin(FName("ElementIndex"))->DefaultValue = FString::FromInt(materialIndex);

				//Create select node
				const UK2Node_Select* selectNode = Logi::BlueprintUtils::CreateBPSelectNode(FunctionGraph, xPosition, 300);

				//Set the select node's option 0 pin to the mesh component material
				selectNode->FindPin(FName("Option 0"))->DefaultObject = meshComponentMaterial;

				//Create a getter node for the Logi_DynamicMaterialInstance variable
				const UK2Node_VariableGet* getLogiDynamicMaterialInstance = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_DynamicMaterialInstance"), xPosition - 250, 300);

				//Connect the Logi_DynamicMaterialInstance getter node to the select node
				Schema->TryCreateConnection(getLogiDynamicMaterialInstance->GetValuePin(), selectNode->FindPin(FName("Option 1")));

				//Connect the setMaterialNode to the select node
				Schema->TryCreateConnection(selectNode->GetReturnValuePin(), setMaterialNode->FindPin(FName("Material")));


				//Create getter node for material index
				const UK2Node_VariableGet* materialIndexGetterNode = Logi::BlueprintUtils::CreateBPGetterNode(FunctionGraph, FName("Logi_MaterialIndex"), xPosition - 150, 600);

				//Connect the material index getter node to the select node
				Schema->TryCreateConnection(materialIndexGetterNode->GetValuePin(), selectNode->FindPin(FName("Index")));

				//Connect the exec pin of the select node to the set material node
				if (firstLoop) {
					Schema->TryCreateConnection(setBaseTemperatureScalarParameterNode->GetThenPin(), setMaterialNode->GetExecPin());
					firstLoop = false;
				}
				else {
					Schema->TryCreateConnection(previousSetMaterialNode->GetThenPin(), setMaterialNode->GetExecPin());
				}

				previousSetMaterialNode = setMaterialNode;

				materialIndex++;
				xPosition += 600;
			}
		}
		

	}

	UEdGraph* AddSetupFunctionToNonLogiActor(const FAssetData& Actor) {

		UBlueprint* Blueprint = Cast<UBlueprint>(Actor.GetAsset());
		const FName FunctionName = FName("Logi_ThermalActorSetup");


		//Validate blueprint
		if (!Blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Blueprint is null, cannot add setup function."));
			return nullptr;
		}

		// Check if the setup function already exists in the blueprint
		for (const UEdGraph* Graph : Blueprint->FunctionGraphs)
		{
			if (Graph && Graph->GetFName() == FunctionName)
			{
				UE_LOG(LogTemp, Warning, TEXT("Function '%s' already exists in blueprint '%s', skipping implementation."), *FunctionName.ToString(), *Blueprint->GetName());
				return nullptr;
			}
		}


		// Create the setup function
		UEdGraph* NewFunctionGraph = FBlueprintEditorUtils::CreateNewGraph(Blueprint, FunctionName, UEdGraph::StaticClass(), UEdGraphSchema_K2::StaticClass());
		FBlueprintEditorUtils::AddFunctionGraph<UFunction>(Blueprint, NewFunctionGraph,true, nullptr);

		// Find the setup function entry node
		const UK2Node_FunctionEntry* EntryNode = nullptr;
		for (UEdGraphNode* Node : NewFunctionGraph->Nodes)
		{
			EntryNode = Cast<UK2Node_FunctionEntry>(Node);
			if (EntryNode)
				break;
		}

		//Mark blueprint as modified
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(Blueprint);

		UE_LOG(LogTemp, Log, TEXT("Function 'Logi_ThermalActorSetup' successfully added to blueprint '%s'."), *Blueprint->GetName());

		AddNodeSetupToSetupFunction(NewFunctionGraph, EntryNode);

		return NewFunctionGraph;
	}

	UEdGraph* AddUpdateThermalMaterialFunctionToNonLogiActor(const FAssetData& Actor) {

		UBlueprint* Blueprint = Cast<UBlueprint>(Actor.GetAsset());
		const FName FunctionName = FName("Logi_UpdateThermalMaterial");

		//Validate blueprint
		if (!Blueprint) {
			UE_LOG(LogTemp, Error, TEXT("Blueprint is null, cannot add setup function."));
			return nullptr;
		}

		// Check if the setup function already exists in the blueprint
		for (const UEdGraph* Graph : Blueprint->FunctionGraphs)
		{
			if (Graph && Graph->GetFName() == FunctionName)
			{
				UE_LOG(LogTemp, Warning, TEXT("Function '%s' already exists in blueprint '%s', skipping implementation."), *FunctionName.ToString(), *Blueprint->GetName());
				return nullptr;
			}
		}


		// Create the setup function
		UEdGraph* NewFunctionGraph = FBlueprintEditorUtils::CreateNewGraph(Blueprint, FunctionName, UEdGraph::StaticClass(), UEdGraphSchema_K2::StaticClass());
		FBlueprintEditorUtils::AddFunctionGraph<UFunction>(Blueprint, NewFunctionGraph, true, nullptr);

		// Find the setup function entry node
		UK2Node_FunctionEntry* EntryNode = nullptr;
		for (UEdGraphNode* Node : NewFunctionGraph->Nodes)
		{
			EntryNode = Cast<UK2Node_FunctionEntry>(Node);
			if (EntryNode)
				break;
		}

		//Add node setup to function graph
		AddNodeSetupToUpdateThermalMaterialFunction(NewFunctionGraph, EntryNode);


		//Mark blueprint as modified
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(Blueprint);

		UE_LOG(LogTemp, Log, TEXT("Function 'Logi_ThermalActorSetup' successfully added to blueprint '%s'."), *Blueprint->GetName());

		return NewFunctionGraph;
	}

	void MakeProjectBPActorsLogiCompatible() {
		//Create a list to hold all the actor blueprints in the project
		TArray<FAssetData> ProjectActors;
		//Find all the blueprints of type Actor in the /games (content) folder and add them to the projectActors list
		FindAllNonLogiActorBlueprintsInProject(ProjectActors);

		//Add Logi variables to all the actor blueprints in the project
		for (FAssetData Actor : ProjectActors) {
			//Prints status
			UE_LOG(LogTemp, Warning, TEXT("Adding Logi variables to actor: %s"), *Actor.AssetName.ToString());

			//Add Logi variables to the actor blueprint
			AddLogiVariablesToActorBlueprint(Actor);
			//Add Logi functions to the actor blueprint
			AddSetupFunctionToNonLogiActor(Actor);
			AddUpdateThermalMaterialFunctionToNonLogiActor(Actor);

			// Gets and validates the Blueprint
			UBlueprint* Blueprint = Cast<UBlueprint>(Actor.GetAsset());
			if (!Blueprint) {
				UE_LOG(LogTemp, Error, TEXT("Failed to cast actor asset '%s' to Blueprint"), *Actor.AssetName.ToString());
				continue;
			}

			// Finds the blueprints event graph
			UEdGraph* EventGraph = nullptr;
			for (UEdGraph* Graph : Blueprint->UbergraphPages) {
				if (Graph && Graph->GetFName() == FName(TEXT("EventGraph"))) {
					EventGraph = Graph;
					break;
				}
			}

			//Validate the event graph
			if (!EventGraph) {
				UE_LOG(LogTemp, Error, TEXT("No EventGraph found in Blueprint '%s'"), *Blueprint->GetName());
				continue;
			}

			//Find the Schema of the event graph
			const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();

			//Validate the schema
			if (!Schema) {
				UE_LOG(LogTemp, Error, TEXT("Failed to get the schema for the EventGraph in Blueprint '%s'"), *Blueprint->GetName());
				continue;
			}

			//Check if the Logi_LogiThermalActorSetup function referece nodes already exists in the event graph
			bool logiThermalActorSetupFunctionNodeAlreadyExists = false;
			for (UEdGraphNode* node : EventGraph->Nodes)
			{
				if (UK2Node_CallFunction* callFuncNode = Cast<UK2Node_CallFunction>(node))
				{
					if (callFuncNode->FunctionReference.GetMemberName() == FName("Logi_ThermalActorSetup"))
					{
						logiThermalActorSetupFunctionNodeAlreadyExists = true;
						break;
					}
				}
			}

			//Check if the Logi_UpdateThermalMaterial function referece nodes already exists in the event graph
			bool bLogiUpdateThermalMaterialFunctionNodeAlreadyExists = false;
			for (UEdGraphNode* Node : EventGraph->Nodes)
			{
				if (UK2Node_CallFunction* CallFuncNode = Cast<UK2Node_CallFunction>(Node))
				{
					if (CallFuncNode->FunctionReference.GetMemberName() == FName("Logi_UpdateThermalMaterial"))
					{
						bLogiUpdateThermalMaterialFunctionNodeAlreadyExists = true;
						break;
					}
				}
			}


			// Add call function for Logi_ThermalActorSetup function to actor blueprint if it does not already exist
			if (!logiThermalActorSetupFunctionNodeAlreadyExists) {
				// Find BeginPlay node
				UK2Node_Event* BeginPlayNode = nullptr;
				for (UEdGraphNode* Node : EventGraph->Nodes) {
					UK2Node_Event* EventNode = Cast<UK2Node_Event>(Node);
					if (EventNode && EventNode->EventReference.GetMemberName() == FName(TEXT("ReceiveBeginPlay"))) {
						BeginPlayNode = EventNode;
						break;
					}
				}

				//if the event begin play node is not in the event graph, create it
				if (!BeginPlayNode) {
					// If not found, create the BeginPlay event node
					BeginPlayNode = NewObject<UK2Node_Event>(EventGraph);
					EventGraph->AddNode(BeginPlayNode);
					BeginPlayNode->EventReference.SetExternalMember(FName(TEXT("ReceiveBeginPlay")), AActor::StaticClass());
					BeginPlayNode->bOverrideFunction = true;
					BeginPlayNode->NodePosX = 0;
					BeginPlayNode->NodePosY = 0;
					BeginPlayNode->AllocateDefaultPins();

					UE_LOG(LogTemp, Warning, TEXT("Created new Event BeginPlay node in Blueprint '%s'"), *Blueprint->GetName());
				}

				// Create a call function node to call the Logi_ThermalActorSetup function
				UK2Node_CallFunction* CallSetupFunctionNode = Logi::BlueprintUtils::CreateBPCallFunctionNode(EventGraph, FName("Logi_ThermalActorSetup"), BeginPlayNode->NodePosX + 200, BeginPlayNode->NodePosY);

				//find the BeginPlay node's then pin
				UEdGraphPin* BeginPlayThenPin = BeginPlayNode->FindPin(UEdGraphSchema_K2::PN_Then);

				//Check if there are nodes already connected to the BeginPlay node
				if (BeginPlayThenPin) {
					//Check if the BeginPlay node has any linked nodes, if so make connection between the call function node and the node connected to the BeginPlay node
					if (BeginPlayThenPin->LinkedTo.Num() > 0) {
						//Find the pin connected to the BeginPlay node
						UEdGraphPin* OriginalConnectedPin = BeginPlayThenPin->LinkedTo[0];

						//Break connection between begin play node and the node connected to it
						Schema->BreakPinLinks(*BeginPlayThenPin, false);

						//connect the BeginPlay node to the call function node
						Schema->TryCreateConnection(CallSetupFunctionNode->GetThenPin(), OriginalConnectedPin);

						//Connect BeginPlay node to the call function node
						Schema->TryCreateConnection(BeginPlayThenPin, CallSetupFunctionNode->GetExecPin());

					}
					else {
						Schema->TryCreateConnection(BeginPlayThenPin, CallSetupFunctionNode->GetExecPin());
					}
				}
			}

			// Create a call function node to call the Logi_UpdateThermalMaterial function
			if (!bLogiUpdateThermalMaterialFunctionNodeAlreadyExists) {

				// Find EventTick node
				UK2Node_Event* EventTickNode = nullptr;
				for (UEdGraphNode* Node : EventGraph->Nodes) {
					UK2Node_Event* EventNode = Cast<UK2Node_Event>(Node);
					if (EventNode && EventNode->EventReference.GetMemberName() == FName(TEXT("ReceiveTick"))) {
						EventTickNode = EventNode;
						break;
					}
				}

				//if the event begin play node is not in the event graph, create it
				if (!EventTickNode) {
					// If not found, create the BeginPlay event node
					EventTickNode = NewObject<UK2Node_Event>(EventGraph);
					EventGraph->AddNode(EventTickNode);
					EventTickNode->EventReference.SetExternalMember(FName(TEXT("ReceiveTick")), AActor::StaticClass());
					EventTickNode->bOverrideFunction = true;
					EventTickNode->NodePosX = 0;
					EventTickNode->NodePosY = 0;
					EventTickNode->AllocateDefaultPins();

					UE_LOG(LogTemp, Warning, TEXT("Created new Event eventTickNode node in Blueprint '%s'"), *Blueprint->GetName());
				}

				//find the eventTick node's then and value pin
				UEdGraphPin* EventTickThenPin = EventTickNode->FindPin(UEdGraphSchema_K2::PN_Then);
				UEdGraphPin* EventTickValuePin = EventTickNode->FindPin(FName("DeltaSeconds"));

				// Create a call function node to call the Logi_ThermalActorSetup function
				UK2Node_CallFunction* CallUpdateThermalMaterialNode= Logi::BlueprintUtils::CreateBPCallFunctionNode(EventGraph, FName("Logi_UpdateThermalMaterial"), EventTickNode->NodePosX + 200, EventTickNode->NodePosY);

				//Check if there are nodes already connected to the event tick node
				if (EventTickThenPin) {
					//Check if the event tick has any linked nodes, if so make connection between the call function node and the node connected to the event tick node
					if (EventTickThenPin->LinkedTo.Num() > 0) {
						//Find the pin connected to the BeginPlay node
						UEdGraphPin* OriginalConnectedPin = EventTickThenPin->LinkedTo[0];

						//Break connection between begin play node and the node connected to it
						Schema->BreakPinLinks(*EventTickThenPin, false);

						//connect the BeginPlay node to the call function node
						Schema->TryCreateConnection(CallUpdateThermalMaterialNode->GetThenPin(), OriginalConnectedPin);

						//Connect beginplaynode to the call function node
						Schema->TryCreateConnection(EventTickThenPin, CallUpdateThermalMaterialNode->GetExecPin());
					}
					else {
						Schema->TryCreateConnection(EventTickThenPin, CallUpdateThermalMaterialNode->GetExecPin());
					}
				}
			}
			
		}
	}

}
